Review for the provider’s code

	Our provider’s code was very similar to ours and as a result it was very easy to use the adapter pattern to use methods from our existing code to implement their interfaces. The Javadoc was clear as to the functionality and usability of all of their methods. Following the MVC design, all of the three parts were separated and loosely coupled as much as possible. Their design however failed to completely separate information about the model from the controller, when extending the EditorListener class, however, we realized that there is no “perfect” way to completely separate the data other than trying the best you could. The view included pretty much the same functionality as ours aside from also implementing the extra credit. 
	If they were to improve their design we would suggest that they add more methods to the view that would relay data about the state of the view back to the controller. For example, they had one method on their view that returned the new speed that the user entered into the textbox. More methods that returned what was entered in text fields or what was selected in a JList would have been helpful. For example, there was no way easy for the controller to retrieve all of the necessary information to make new keyframes frames. The lack of these types of methods made it necessary for their view to have a reference to their controller so that the view could pass data to the controller when there was no way for the controller to retrieve it from the view. Also, to help with the organization of the buttons in the editor view, we would suggest using comments or some kind of indicator, even making a class for each button or panel such that it is easily distinguishable and accessible to find in the code. Another design error that we noticed was that the provider required every single field needed to add a keyframe to a shape be filled in on their JFrame even when the user was simply deleting a keyframe. Although it does not break the code, there was no reasonable explanation as to why this was a requirement. If a user, such as us, was simply trying to remove a keyframe without putting in random information, the keyframe would not be able be removed and the user would think that the button functionality was not working as it would display a “no selected keyframe” error message. Another nice implementation to add might be to replace the R, B, and G text values with the Color Chooser which would enable the user to have a visual of what color they were going to expect instead of putting the numbers in or a certain color. Finally, some visual indication of the values of a keyframe besides the time would be helpful in effectively editing keyframes.
Regarding the design of the provider’s code, originally the code was organized such that mostly concrete classes were used as the parameters and return types of methods on their interfaces. Unfortunately, the use of concrete classes caused their code to become tightly coupled to these classes in a way that caused us to not be able to adapt our code to their view; so, we requested them to replace the references to concrete classes with their respective interfaces. The interfaces used in the code all were pertinent to a certain purpose in creating the animation. 

Review for the Experience

	Regarding our own design for the assignment, we could’ve made our controller more functional in comparison to our model and view. I think a lot of the problems we had were regarding our confusion with listeners and how to use and implement them in our controller’s code. If we were to do it again, we would’ve done something similar to our provider’s code and created a listener class and added it to our buttons for functionality. A lot of the problems that we encountered during the implementation of our providers code arose from a difference of implementation of certain methods. While not a bad thing, it definitely gave us a more broader perspective on how other groups implemented certain functionality or their animation along with helping us to understand how to approach similar challenges in the future. For example our providers created a Keyframe class to represent a keyframe whereas we used our existing classes to represent a keyframe. While looking at our provider’s code and requesting changes to be made we also were able to reevaluate our own code and realize that we had similar problems in our code to theirs. They used concrete classes in the place of interfaces on the parameters of some methods. We found a similar mistake in our code that we had to fix for our customers. Our interaction with our providers helped us realize problems in our code that we had previously missed or didn’t realize while going through our provider’s code. Our experience with our providers was very effective. They were always responsive and willing to help explain and provide us with any information that we were missing or confused about. They also made quick and effective changes to their code so that we were able to continue working on implementing their code with ours. The experience has helped us to seperate ourselves from a designer’s perspective and look at our code as a future user. It has helped us to realize how overly complicated we might have made certain aspects of our code along with any design mistakes that we made from making certain data tightly coupled instead of loosely coupled for the user to access easily. 
